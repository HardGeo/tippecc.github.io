//WAS GENERATED BY
//----------------------------------------------------------------------------------------
export function findFirstEntity(generatedToUsedMap: any, usedToGeneratedMap: any) {
    // Find the first entity that is generated but not used by another
    return Array.from(generatedToUsedMap.keys()).filter(generated => {
        return !Array.from(usedToGeneratedMap.keys()).includes(generated);
    });
}
//------------------------------------------------------------
export function createEntityFlowCore(
    wasDerivedFrom: any,
    GeneratedName: string,
    UsedName: string ) 
    {
    // Create maps to store relationships
    const generatedToUsedMap = new Map<string, string[]>();
    const usedToGeneratedMap = new Map<string, string[]>();

    // Populate the maps
    for (const entry of Object.values(wasDerivedFrom)) {
        const generated = entry[GeneratedName]; //'prov:generatedEntity'
        const used = entry[UsedName]; // 'prov:usedEntity'

        // Update generatedToUsedMap
        if (!generatedToUsedMap.has(generated)) {
            generatedToUsedMap.set(generated, []);
        }
        generatedToUsedMap.get(generated)!.push(used);

        // Update usedToGeneratedMap
        if (!usedToGeneratedMap.has(used)) {
            usedToGeneratedMap.set(used, []);
        }
        usedToGeneratedMap.get(used)!.push(generated);
    }

    const startEntities = findFirstEntity (generatedToUsedMap,   usedToGeneratedMap)

    return { startEntities , generatedToUsedMap};
}
//-----------------------------------------------------------------------

export function createEntityFlow(
dataset: any,
nodes: any, 
edges: any, 
color: string,
border_radius: string,
height: string,
label: string,
swapArrow: boolean,
): void {
// Function to print all derivations starting from a given entity

// Create Entities
const { startEntities, generatedToUsedMap } = createEntityFlowCore(dataset.wasDerivedFrom, 'prov:generatedEntity', 'prov:usedEntity');


// Process all starting entities
for (let startEntity of startEntities) {
    let queue = [startEntity];

    let visited = new Set<string>();
    let yPosition = 0;

    while (queue.length > 0) {
        let currentEntity = queue.shift()!;
        if (visited.has(currentEntity)) continue;
        visited.add(currentEntity);
        
        const variables = dataset.entity[currentEntity]["cf:variables"];
        
        // EXTRACT PARAMTER NAME
        // Split the string at ", ", find the part starting with "name:", and extract the value
        const name = variables
        .split(", ")  // Split into an array by commas
        .find(part => part.startsWith("name:"))  // Find the segment starting with "name:"
        ?.split(": ")[1];  // Split by ": " and get the value after the colon
        
        //EXTRACT UNIT
        const unit = variables
        .split(", ")  // Split into an array by commas
        .find(part => part.startsWith("units:"))  // Find the segment starting with "units:"
        ?.split(": ")[1];  // Split by ": " and get the value after the colon
        

        //EXTRACT TIMESPAN
        function parseTimespans(timespans: string): { start: number; end: number }[] {
            if (!timespans) {
              return [];  // Return an empty array if no timespans data is available
            }
          
            // Process the timespans string by splitting it at ", " for multiple ranges
            return timespans.split(", ").map(range => {
              const [start, end] = range.split("-").map(Number);  // Split each range by "-" and convert to numbers
              return { start, end };
            });
          }
        // Safe access to the timespans data
        const timespans = dataset?.entity?.[currentEntity]?.["dcterms:temporal"];
        // Parse the timespans string
        const parsedTimespans = parseTimespans(timespans);
        
        
        // EXTRACT BBOXES
        const Bboxes = dataset.entity[currentEntity]["dcterms:spatial"];
        // Regular expression to match numbers inside square brackets
        const regex = /\[([^\]]+)\]/g;
        const matches = [...Bboxes.matchAll(regex)]; // Get all matches
        // Extract numbers from matches and convert them to arrays
        const boundingBoxes = matches.map(match => match[1].split(', ').map(Number));
        const extent = boundingBoxes[0]
        const extent_orig = boundingBoxes[1]


        // EXTRACT COLLECTION
        function findCollectionForEntity(currentEntity, hadMember) {
            // Iterate through the hadMember object to find the matching collection
            const entry = Object.values(hadMember).find(member => member["prov:entity"] === currentEntity);
            return entry ? entry["prov:collection"] : "No Collection defined";
        }
        const collection = findCollectionForEntity(currentEntity, dataset.hadMember);

           
        // Add node for currentEntity
        nodes.update(n => {
            if (!n.some(node => node.id === currentEntity)) {
                n.push({
                    id: currentEntity,
                    type: 'entityNode', // Specify the custom node type
                    data: {
                        parameter: name,
                        zeitspranne: parsedTimespans,
                        regionalmodell: dataset.entity[currentEntity]["tippecc:regionalmodel"],
                        globalmodell: dataset.entity[currentEntity]["tippecc:globalmodel"],
                        einheit: unit,
                        szenario: dataset.entity[currentEntity]["tippecc:scenario"],
                        format: dataset.entity[currentEntity]["datacite:format"],
                        resolutionZeitlich: dataset.entity[currentEntity]["dcat:temporalResolution"],
                        resolutionRaeumlich: dataset.entity[currentEntity]["dcat:spatialResolutionInMeters"]["$"],
                        spatialExtent: extent,
                        spatialExtent_orig: extent_orig,
                        dateigroesse: dataset.entity[currentEntity]["datacite:size"],
                        timestamp: dataset.entity[currentEntity]["prov:generatedAtTime"],
                        project: dataset.entity[currentEntity]["sdo:project"],
                        experiment: dataset.entity[currentEntity]["tippecc:experiment"],
                        standard: dataset.entity[currentEntity]["cf:standard"],
                        bias: dataset.entity[currentEntity]["tippecc:bias"],
                        source: dataset.entity[currentEntity]["dcterms:publisher"],
                        institution: dataset.entity[currentEntity]["dcterms:creator"],
                        domain: dataset.entity[currentEntity]["tippecc:domain"],
                        contact: dataset.entity[currentEntity]["tippecc:contact"],
                        tracking_id: dataset.entity[currentEntity]["esgf_portal:tracking_id"],
                        doi: dataset.entity[currentEntity]["dcterms:identifier"],
                        collection: collection

                    },
                    position: { x: 0, y: yPosition },
                    style: `background: ${color}; ${border_radius}; ${height}; border: 2px solid black;`
                });
                yPosition += 400;       
            }
            return n;
        });

        // Add edges to connected entities
        if (generatedToUsedMap.has(currentEntity)) {
            for (const usedEntity of generatedToUsedMap.get(currentEntity)!) {
                const source = swapArrow ? usedEntity : currentEntity;
                const target = swapArrow ? currentEntity : usedEntity;
                edges.update(e => {
                    e.push({
                        id: `${usedEntity}-${currentEntity}`,
                        source: source,
                        target: target,
                        animated: false,
                        label: label,
                        type: 'default',
                        labelStyle: 'color: black; font-size: 16px; z-index: 2; pointer-events: none;'
                    });
                    return e;
                });

                // Continue traversing from the used entity
                queue.push(usedEntity);
            }
        }
    }
}
}

export function createActionFlow(
    dataset:any,
    nodes: any, 
    edges: any, 
    color: string,
    border_radius: string,
    height: string,
    label: string,
    swapArrow: boolean
    ): void {
    // Function to print all derivations starting from a given entity

    // Create Actions (renaming for consistency)
    const { 
        startEntities: startActions, 
        generatedToUsedMap: generatedToUsedMapAction } = createEntityFlowCore(
            dataset.wasInformedBy, 
            'prov:informed', 
            'prov:informant'
        );
    
    for (let startAction of startActions) {
        let queue = [startAction];
        let visited = new Set<string>();
        let yPosition = 0;
        while (queue.length > 0) {
            let currentEntity = queue.shift()!;
            if (visited.has(currentEntity)) continue;
            visited.add(currentEntity);
        
            // Add node for currentEntity
            nodes.update(n => {
                if (!n.some(node => node.id === currentEntity)) {
                    n.push({
                        id: currentEntity,
                        type: 'activityNode', // Specify the custom node type
                        data: {
                            aggregateInfo: currentEntity,
        
                        },
                        position: { x: 700, y:yPosition }, // Randomized for simplicity
                        style: `background: ${color}; ${border_radius}; ${height}; border: 2px solid black;`
                    });
                    yPosition += 400;
                }
                return n;
            });
        
            // Add edges to connected entities
            if (generatedToUsedMapAction.has(currentEntity)) {
                for (const usedEntity of generatedToUsedMapAction.get(currentEntity)!) {
                    const source = swapArrow ? usedEntity : currentEntity;
                    const target = swapArrow ? currentEntity : usedEntity;
                    edges.update(e => {
                        e.push({
                            id: `${usedEntity}-${currentEntity}`,
                            source: source,
                            target: target,
                            animated: false,
                            label: label,
                            type: 'default',
                            labelStyle: 'color: black; font-size: 16px; z-index: 2; pointer-events: none;'
                        });
                        return e;
                    });
        
                    // Continue traversing from the used entity
                    queue.push(usedEntity);
                }
            }
        }
        }
}

//-----------------------------------------------------------------------------


export function createPeople ({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    swapArrow,
    edgeStyle
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    swapArrow: boolean,
    edgeStyle: string
}) {
    const entityNodes = new Set(); 
    let yPosition = 0;

    for (const [id, member] of Object.entries(dataset.wasAttributedTo)) {
        const personId = member["prov:agent"]; // Use full person identifier (e.g., people:Franzi)
        const entity = member["prov:entity"];

        // Find organization (orgaId) from actedOnBehalfOf
        const actedOnBehalfOfEntry = Object.values(dataset.actedOnBehalfOf).find(
            (entry: any) => entry["prov:delegate"] === personId
        );

        const orgaId = actedOnBehalfOfEntry?.["prov:responsible"] || null;
        const rorid = orgaId ? dataset.agent[orgaId]?.["ror:identifier"] : null;

        // Only add the person node if it hasn't been added yet
        if (!entityNodes.has(personId)) {
            nodes.update(n => {
                n.push({
                    id: personId,
                    type: 'personNode',
                    data: { 
                        person: personId,
                        orga: orgaId || "N/A",
                        orcid: dataset.agent?.[personId]?.["orcid:identifier"] || "N/A",
                        rorid: rorid || "N/A"
                    },
                    position: { x: -600, y: yPosition },
                    style: `background: ${color}; ${border_radius}; width: ${personId.length * 10}px; ${height}; border: 2px solid black`
                });
                return n;
            });
            entityNodes.add(personId);
            yPosition += 400;
        }

        // Add edge between the person and the corresponding entity
        const source = swapArrow ? entity : personId;
        const target = swapArrow ? personId : entity;
        const sourceHandle = swapArrow ? `${entity}-left` : `${personId}-right`;
        const targetHandle = swapArrow ? `${personId}-right` : `${entity}-left`;

        edges.update(e => {
            e.push({
                id: `${personId}-${entity}`,
                source: source,
                target: target,
                sourceHandle: sourceHandle,
                targetHandle: targetHandle,
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: 'color: black; font-size: 16px'
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------


/*
// ADD ORGANISATIONS

export function addOrga ({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgeStyle
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgeStyle: string
}) {
    let yPosition = 0;
    const entityNodes = new Set();
    for (const [id, member] of Object.entries(dataset.actedOnBehalfOf)) {
        const Id = member[IdName]; // Use name as the ID
        const entity = member[EntityName];
        
        // Only add the collection node if it hasn't been added yet
        if (!entityNodes.has(Id)) {
            // Add node
            nodes.update(n => {
                n.push({
                    id: Id,
                    type: 'orgaNode',
                    data: {
                        orga: Id,
                        rorid: dataset.agent[Id]["ror:identifier"]
                     },
                    position: { x:-800, y: yPosition }, // Adjust position as needed
                    style: `background: ${color}; ${border_radius}; width: ${Id.length*10}px;${height}; border: 2px solid black`
                });
                return n;
            });
            entityNodes.add(Id); // Mark this entity as added
            yPosition += 400;
        }

        // Add edge between the collection and the corresponding entity
        const source = swapArrow ? entity : Id;
        const target = swapArrow ? Id : entity;
        edges.update(e => {
            e.push({
                id: `${Id}-${entity}`,
                source:source,
                target:target,
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: 'color: black; font-size: 16px',
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
*/


//ADD Nodes and Edges for Software
export function addSoftware({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    style,
    swapArrow,
    edgestyle
}: {
    dataset: any, 
    nodes: any,
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    style: string,
    swapArrow: boolean,
    edgestyle: string
}) {
    let yPosition = 0;
    for (const member of Object.values(dataset.wasAssociatedWith)) {
        const activityId = member[IdName];
        const agentId = member[EntityName];
        
        // Ensure agent node is added if not present
        nodes.update(n => {
            if (!n.some(node => node.id === agentId)) {
                n.push({
                    id: agentId,
                    type: 'softwareNode',
                    data: {
                        software: agentId,
                        source: dataset.agent[agentId]["dcterms:source"],
                        version: dataset.agent[agentId]["sdo:version"],
                        repository: dataset.agent[agentId]["sdo:codeRepository"],
                        license: dataset.agent[agentId]["sdo:license"]
                     },
                    position: { x: 1200, y: yPosition }, // Adjust as needed
                    style: `background: ${color}; ${border_radius}; width: ${agentId.length*10}px;${height}; border: 2px solid black`
                });
            }
            return n;
        });
        yPosition += 400;

        // Define edge direction based on swapArrow
        const source = swapArrow ? agentId : activityId;
        const target = swapArrow ? activityId : agentId;
        const sourceHandle = swapArrow ? `${agentId}-left` : `${activityId}-right`; // Use the correct handle
        const targetHandle = swapArrow ? `${activityId}-right` : `${agentId}-left`; // Use the correct handle
        
        // Add edge between the activity and agent
        edges.update(e => {
            e.push({
                id: `${activityId}-${agentId}`,
                source: source,
                target: target, 
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: edgestyle,
                labelStyle: 'color: black; font-size: 16px',
            });
            return e;
        });
    }
}


// ADD EDGES ONLY
export function addEdgesOnly({
    dataset,
    edges,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    style,
    labelStyle,
    handle1,
    handle2
    //edgeStyle = {} // Allow optional edge style customization
}: {
    dataset: any, 
    edges: any,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    style: string,
    labelStyle: string,
    handle1: string,
    handle2: string
}) {
    for (const member of Object.values(dataset)) {
        const activityId = member[IdName];
        const entityId = member[EntityName];
        
        // Define edge direction based on swapArrow
        const source = swapArrow ? entityId : activityId;
        const target = swapArrow ? activityId : entityId;

        // Specify the correct handles for source and target
        const sourceHandle = swapArrow ? `${entityId}-${handle1}` : `${activityId}-${handle2}`; // Use entityNode right or activityNode left
        const targetHandle = swapArrow ? `${activityId}-${handle2}` : `${entityId}-${handle1}`; // Use activityNode left or entityNode right
        
        // Add edge between activity and entity
        edges.update(e => {
            e.push({
                id: `${activityId}-${entityId}`,
                source: source,
                target: target,
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: style,
                labelStyle: labelStyle
            });
            return e;
        });
    }
}

