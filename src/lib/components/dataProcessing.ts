//WAS GENERATED BY
//----------------------------------------------------------------------------------------
export function findFirstEntity(generatedToUsedMap: any, usedToGeneratedMap: any) {
    // Find the first entity that is generated but not used by another
    return Array.from(generatedToUsedMap.keys()).filter(generated => {
        return !Array.from(usedToGeneratedMap.keys()).includes(generated);
    });
}
//------------------------------------------------------------
export function createEntityFlowCore(
    wasDerivedFrom: any,
    GeneratedName: string,
    UsedName: string ) 
    {
    // Create maps to store relationships
    const generatedToUsedMap = new Map<string, string[]>();
    const usedToGeneratedMap = new Map<string, string[]>();

    // Populate the maps
    for (const entry of Object.values(wasDerivedFrom)) {
        const generated = entry[GeneratedName]; //'prov:generatedEntity'
        const used = entry[UsedName]; // 'prov:usedEntity'

        // Update generatedToUsedMap
        if (!generatedToUsedMap.has(generated)) {
            generatedToUsedMap.set(generated, []);
        }
        generatedToUsedMap.get(generated)!.push(used);

        // Update usedToGeneratedMap
        if (!usedToGeneratedMap.has(used)) {
            usedToGeneratedMap.set(used, []);
        }
        usedToGeneratedMap.get(used)!.push(generated);
    }

    const startEntities = findFirstEntity (generatedToUsedMap,   usedToGeneratedMap)

    return { startEntities , generatedToUsedMap};
}
//-----------------------------------------------------------------------

export function createEntityFlow(
dataset: any,
nodes: any, 
edges: any, 
color: string,
border_radius: string,
height: string,
label: string,
swapArrow: boolean,
): void {
// Function to print all derivations starting from a given entity

// Create Entities
const { startEntities, generatedToUsedMap } = createEntityFlowCore(dataset.wasDerivedFrom, 'prov:generatedEntity', 'prov:usedEntity');


// Process all starting entities
for (let startEntity of startEntities) {
    let queue = [startEntity];

    let visited = new Set<string>();
    let yPosition = 0;

    while (queue.length > 0) {
        let currentEntity = queue.shift()!;
        if (visited.has(currentEntity)) continue;
        visited.add(currentEntity);


        // Add node for currentEntity
        nodes.update(n => {
            if (!n.some(node => node.id === currentEntity)) {
                n.push({
                    id: currentEntity,
                    type: 'entityNode', // Specify the custom node type
                    data: {
                        parameter: dataset.entity[currentEntity]["parameter"],   
                        zeitspranne: dataset.entity[currentEntity]["zeitspranne"],
                        regionalmodell: dataset.entity[currentEntity]["regionalmodell"],
                        globalmodell: dataset.entity[currentEntity]["globalmodell"],
                        einheit: dataset.entity[currentEntity]["einheit"],
                        szenario: dataset.entity[currentEntity]["szenario"],
                        format: dataset.entity[currentEntity]["format"],
                        resolutionZeitlich: dataset.entity[currentEntity]["resolutionZeitlich"],
                        resolutionRaeumlich: dataset.entity[currentEntity]["resolutionRaeumlich"],
                        spatialExtent: dataset.entity[currentEntity]["spatialExtent"],
                        spatialExtent_orig: dataset.entity[currentEntity]["spatialExtent_orig"],
                        dateigroesse: dataset.entity[currentEntity]["dateigroesse"],
                        timestamp: dataset.entity[currentEntity]["timestamp"],
                        project: dataset.entity[currentEntity]["project"],
                        experiment: dataset.entity[currentEntity]["experiment"],
                        standard: dataset.entity[currentEntity]["standard"],
                        bias: dataset.entity[currentEntity]["bias"],
                        source: dataset.entity[currentEntity]["source"],
                        institution: dataset.entity[currentEntity]["institution"],
                        domain: dataset.entity[currentEntity]["domain"],
                        contact: dataset.entity[currentEntity]["contact"],
                        tracking_id: dataset.entity[currentEntity]["tracking_id"],
                        doi: dataset.entity[currentEntity]["doi"]

                    },
                    position: { x: 0, y: yPosition },
                    style: `background: ${color}; ${border_radius}; ${height}; border: 2px solid black;`
                });
                yPosition += 400;       
            }
            return n;
        });

        // Add edges to connected entities
        if (generatedToUsedMap.has(currentEntity)) {
            for (const usedEntity of generatedToUsedMap.get(currentEntity)!) {
                const source = swapArrow ? usedEntity : currentEntity;
                const target = swapArrow ? currentEntity : usedEntity;
                edges.update(e => {
                    e.push({
                        id: `${usedEntity}-${currentEntity}`,
                        source: source,
                        target: target,
                        animated: false,
                        label: label,
                        type: 'default',
                        labelStyle: 'color: black; font-size: 12px; z-index: 2; pointer-events: none;'
                    });
                    return e;
                });

                // Continue traversing from the used entity
                queue.push(usedEntity);
            }
        }
    }
}
}

export function createActionFlow(
    dataset:any,
    nodes: any, 
    edges: any, 
    color: string,
    border_radius: string,
    height: string,
    label: string,
    swapArrow: boolean
    ): void {
    // Function to print all derivations starting from a given entity

    // Create Actions (renaming for consistency)
    const { 
        startEntities: startActions, 
        generatedToUsedMap: generatedToUsedMapAction } = createEntityFlowCore(
            dataset.wasInformedBy, 
            'prov:informed', 
            'prov:informant'
        );
    
    for (let startAction of startActions) {
        let queue = [startAction];
        let visited = new Set<string>();
        let yPosition = 0;
        while (queue.length > 0) {
            let currentEntity = queue.shift()!;
            if (visited.has(currentEntity)) continue;
            visited.add(currentEntity);
        
            // Add node for currentEntity
            nodes.update(n => {
                if (!n.some(node => node.id === currentEntity)) {
                    n.push({
                        id: currentEntity,
                        type: 'activityNode', // Specify the custom node type
                        data: {
                            aggregateInfo: currentEntity,
        
                        },
                        position: { x: 700, y:yPosition }, // Randomized for simplicity
                        style: `background: ${color}; ${border_radius}; ${height}; border: 2px solid black;`
                    });
                    yPosition += 400;
                }
                return n;
            });
        
            // Add edges to connected entities
            if (generatedToUsedMapAction.has(currentEntity)) {
                for (const usedEntity of generatedToUsedMapAction.get(currentEntity)!) {
                    const source = swapArrow ? usedEntity : currentEntity;
                    const target = swapArrow ? currentEntity : usedEntity;
                    edges.update(e => {
                        e.push({
                            id: `${usedEntity}-${currentEntity}`,
                            source: source,
                            target: target,
                            animated: false,
                            label: label,
                            type: 'default',
                            labelStyle: 'color: black; font-size: 12px; z-index: 2; pointer-events: none;'
                        });
                        return e;
                    });
        
                    // Continue traversing from the used entity
                    queue.push(usedEntity);
                }
            }
        }
        }
}

//-----------------------------------------------------------------------------


// ADD PEOPLE
export function createPeople ({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgeStyle
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgeStyle: string
}) {
    // Process hadMember to create collections
    const entityNodes = new Set(); // Keep track of added collection nodes

    let yPosition = 0;

    for (const [id, member] of Object.entries(dataset.wasAttributedTo)) {
        
        
        const Id = member[IdName]; // Use collection name as the ID
        const entity = member[EntityName];
        console.log(dataset.agent);

        // Only add the collection node if it hasn't been added yet
        if (!entityNodes.has(Id)) {
            // Add collection node
            nodes.update(n => {
                n.push({
                    id: Id,
                    type: 'personNode',
                    data: { person: Id,
                            orcid: dataset.agent[Id]["orcid"]
                     },
                    position: { x:-500, y: yPosition }, // Adjust position as needed
                    style: `background: ${color}; ${border_radius}; width: ${Id.length*10}px;${height}; border: 2px solid black`
                });
                return n;
            });
            entityNodes.add(Id); // Mark this entity as added
            yPosition += 400;
        }

        // Add edge between the collection and the corresponding entity
        const source = swapArrow ? entity : Id;
        const target = swapArrow ? Id : entity;
        const sourceHandle = swapArrow ? `${entity}-left` : `${Id}-right`; // Use personNode right or entityNode left
        const targetHandle = swapArrow ? `${Id}-right` : `${entity}-left`; // Use entityNode left or personNode right

        edges.update(e => {
            e.push({
                id: `${Id}-${entity}`,
                source:source,
                target:target,
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: 'color: black;',
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
// ADD ORGANISATIONS
export function addOrga ({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgeStyle
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgeStyle: string
}) {
    let yPosition = 0;
    const entityNodes = new Set();
    for (const [id, member] of Object.entries(dataset.actedOnBehalfOf)) {
        const Id = member[IdName]; // Use name as the ID
        const entity = member[EntityName];
        
        // Only add the collection node if it hasn't been added yet
        if (!entityNodes.has(Id)) {
            // Add node
            nodes.update(n => {
                n.push({
                    id: Id,
                    type: 'orgaNode',
                    data: {
                        orga: Id,
                        rorid: dataset.agent[Id]["rorid"]
                     },
                    position: { x:-800, y: yPosition }, // Adjust position as needed
                    style: `background: ${color}; ${border_radius}; width: ${Id.length*10}px;${height}; border: 2px solid black`
                });
                return n;
            });
            entityNodes.add(Id); // Mark this entity as added
            yPosition += 400;
        }

        // Add edge between the collection and the corresponding entity
        const source = swapArrow ? entity : Id;
        const target = swapArrow ? Id : entity;
        edges.update(e => {
            e.push({
                id: `${Id}-${entity}`,
                source:source,
                target:target,
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: 'color: black;',
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------



//ADD Nodes and Edges for Software
export function addSoftware({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    style,
    swapArrow,
    edgestyle
}: {
    dataset: any, 
    nodes: any,
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    style: string,
    swapArrow: boolean,
    edgestyle: string
}) {
    let yPosition = 0;
    for (const member of Object.values(dataset.wasAssociatedWith)) {
        const activityId = member[IdName];
        const agentId = member[EntityName];
        
        // Ensure agent node is added if not present
        nodes.update(n => {
            if (!n.some(node => node.id === agentId)) {
                n.push({
                    id: agentId,
                    type: 'softwareNode',
                    data: {
                        software: agentId,
                        source: dataset.agent[agentId]["source"],
                        version: dataset.agent[agentId]["version"],
                        repository: dataset.agent[agentId]["repository"],
                        license: dataset.agent[agentId]["license"]
                     },
                    position: { x: 1200, y: yPosition }, // Adjust as needed
                    style: `background: ${color}; ${border_radius}; width: ${agentId.length*10}px;${height}; border: 2px solid black`
                });
            }
            return n;
        });
        yPosition += 400;

        // Define edge direction based on swapArrow
        const source = swapArrow ? agentId : activityId;
        const target = swapArrow ? activityId : agentId;
        const sourceHandle = swapArrow ? `${agentId}-left` : `${activityId}-right`; // Use the correct handle
        const targetHandle = swapArrow ? `${activityId}-right` : `${agentId}-left`; // Use the correct handle
        
        // Add edge between the activity and agent
        edges.update(e => {
            e.push({
                id: `${activityId}-${agentId}`,
                source: source,
                target: target, 
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: edgestyle,
                labelStyle: 'color: black;',
            });
            return e;
        });
    }
}


// ADD EDGES ONLY
export function addEdgesOnly({
    dataset,
    edges,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    style,
    labelStyle,
    handle1,
    handle2
    //edgeStyle = {} // Allow optional edge style customization
}: {
    dataset: any, 
    edges: any,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    style: string,
    labelStyle: string,
    handle1: string,
    handle2: string
}) {
    for (const member of Object.values(dataset)) {
        const activityId = member[IdName];
        const entityId = member[EntityName];
        
        // Define edge direction based on swapArrow
        const source = swapArrow ? entityId : activityId;
        const target = swapArrow ? activityId : entityId;

        // Specify the correct handles for source and target
        const sourceHandle = swapArrow ? `${entityId}-${handle1}` : `${activityId}-${handle2}`; // Use entityNode right or activityNode left
        const targetHandle = swapArrow ? `${activityId}-${handle2}` : `${entityId}-${handle1}`; // Use activityNode left or entityNode right
        
        // Add edge between activity and entity
        edges.update(e => {
            e.push({
                id: `${activityId}-${entityId}`,
                source: source,
                target: target,
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: style,
                labelStyle: labelStyle
            });
            return e;
        });
    }
}

