//WAS GENERATED BY
//----------------------------------------------------------------------------------------
export function findFirstEntity(generatedToUsedMap: any, usedToGeneratedMap: any) {
    // Find the first entity that is generated but not used by another
    return Array.from(generatedToUsedMap.keys()).filter(generated => {
        return !Array.from(usedToGeneratedMap.keys()).includes(generated);
    });
}
//------------------------------------------------------------
export function createEntityFlowCore(
    wasDerivedFrom: any,
    GeneratedName: string,
    UsedName: string ) 
    {
    // Create maps to store relationships
    const generatedToUsedMap = new Map<string, string[]>();
    const usedToGeneratedMap = new Map<string, string[]>();

    // Populate the maps
    for (const entry of Object.values(wasDerivedFrom)) {
        const generated = entry[GeneratedName]; //'prov:generatedEntity'
        const used = entry[UsedName]; // 'prov:usedEntity'

        // Update generatedToUsedMap
        if (!generatedToUsedMap.has(generated)) {
            generatedToUsedMap.set(generated, []);
        }
        generatedToUsedMap.get(generated)!.push(used);

        // Update usedToGeneratedMap
        if (!usedToGeneratedMap.has(used)) {
            usedToGeneratedMap.set(used, []);
        }
        usedToGeneratedMap.get(used)!.push(generated);
    }

    const startEntities = findFirstEntity (generatedToUsedMap,   usedToGeneratedMap)

    return { startEntities , generatedToUsedMap};
}
//-----------------------------------------------------------------------

export function createEntityFlow(
entity: any, 
nodes: any, 
edges: any, 
color: string,
border_radius: string,
height: string,
label: string,
swapArrow: boolean,
generatedToUsedMap: Map<string, string[]> 
): void {
// Function to print all derivations starting from a given entity
let queue = [entity];
let visited = new Set<string>();
let yPosition = 0;

while (queue.length > 0) {
    let currentEntity = queue.shift()!;
    if (visited.has(currentEntity)) continue;
    visited.add(currentEntity);

    // Add node for currentEntity
    nodes.update(n => {
        if (!n.some(node => node.id === currentEntity)) {
            n.push({
                id: currentEntity,
                type: 'entityNode', // Specify the custom node type
                data: {
                    parameter: 'Prec',
                    zeitspranne: [{ start: 1910, end: 1950 }, { start: 1980, end: 2050 }],
                    regionalmodell: 'CLMcom-KIT-CCLM5-0-15',
                    globalmodell: 'NCC-NorESM1-M',
                    einheit: 'kg m-2 s-1',
                    szenario: 'SSP-100',
                    format: 'netCDF',
                    resolutionZeitlich: 'Mon',
                    resolutionRaeumlich: 22,
                    spatialExtent: [11.97, 12.156, 50.523, 51.058],
                    spatialExtent_orig: [11.9, 12.3, 50.3, 51.2],
                    dateigroesse: '200MB',
                    timestamp: '2019-12-09-T14:52:55Z',
                    project: 'CORDEX',
                    experiment: 'historic',
                    standard: 'CF-1.4',
                    bias: 'yes',
                    source: 'Climate Limited-area Modelling Community (CLM-Community)',
                    institution: 'IMK-TRO/KIT, Karlsruhe, Germany in collaboration with the CLM community',
                    domain: 'AFR-22',
                    contact: 'hendrik.feldmann@kit.edu',
                    tracking_id: 'hdl:21.14103/0f700e74-9c64-4638-9fab-e7a2f3d26b26',
                    doi: 'www.exampleDOI.com'

                },
                position: { x: 0, y: yPosition }, // Randomized for simplicity
                style: `background: ${color}; ${border_radius}; ${height}; border: 2px solid black;`
            });
            yPosition += 400;       
        }
        return n;
    });

    // Add edges to connected entities
    if (generatedToUsedMap.has(currentEntity)) {
        for (const usedEntity of generatedToUsedMap.get(currentEntity)!) {
            const source = swapArrow ? usedEntity : currentEntity;
            const target = swapArrow ? currentEntity : usedEntity;
            edges.update(e => {
                e.push({
                    id: `${usedEntity}-${currentEntity}`,
                    source: source,
                    target: target,
                    animated: false,
                    label: label,
                    type: 'default',
                    labelStyle: 'color: black; font-size: 12px; z-index: 2; pointer-events: none;'
                });
                return e;
            });

            // Continue traversing from the used entity
            queue.push(usedEntity);
        }
    }
}
}

export function createActionFlow(
    entity: any, 
    nodes: any, 
    edges: any, 
    color: string,
    border_radius: string,
    height: string,
    label: string,
    swapArrow: boolean,
    generatedToUsedMap: Map<string, string[]> 
    ): void {
    // Function to print all derivations starting from a given entity
    let queue = [entity];
    let visited = new Set<string>();
    let yPosition = 0;
    while (queue.length > 0) {
        let currentEntity = queue.shift()!;
        if (visited.has(currentEntity)) continue;
        visited.add(currentEntity);
    
        // Add node for currentEntity
        nodes.update(n => {
            if (!n.some(node => node.id === currentEntity)) {
                n.push({
                    id: currentEntity,
                    type: 'activityNode', // Specify the custom node type
                    data: {
                        aggregateInfo: currentEntity,
    
                    },
                    position: { x: 700, y:yPosition }, // Randomized for simplicity
                    style: `background: ${color}; ${border_radius}; ${height}; border: 2px solid black;`
                });
                yPosition += 400;
            }
            return n;
        });
    
        // Add edges to connected entities
        if (generatedToUsedMap.has(currentEntity)) {
            for (const usedEntity of generatedToUsedMap.get(currentEntity)!) {
                const source = swapArrow ? usedEntity : currentEntity;
                const target = swapArrow ? currentEntity : usedEntity;
                edges.update(e => {
                    e.push({
                        id: `${usedEntity}-${currentEntity}`,
                        source: source,
                        target: target,
                        animated: false,
                        label: label,
                        type: 'default',
                        labelStyle: 'color: black; font-size: 12px; z-index: 2; pointer-events: none;'
                    });
                    return e;
                });
    
                // Continue traversing from the used entity
                queue.push(usedEntity);
            }
        }
    }
    }

//-----------------------------------------------------------------------------

// ADD PEOPLE
export function createPeople ({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgeStyle
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgeStyle: string
}) {
    // Process hadMember to create collections
    const entityNodes = new Set(); // Keep track of added collection nodes
    let yPosition = 0;
    for (const [id, member] of Object.entries(dataset)) {
        const Id = member[IdName]; // Use collection name as the ID
        const entity = member[EntityName];
        // Only add the collection node if it hasn't been added yet
        if (!entityNodes.has(Id)) {
            // Add collection node
            nodes.update(n => {
                n.push({
                    id: Id,
                    type: 'personNode',
                    data: { person: Id,
                            orcid: '0000-0001-6892-7046'
                     },
                    position: { x:-500, y: yPosition }, // Adjust position as needed
                    style: `background: ${color}; ${border_radius}; width: ${Id.length*10}px;${height}; border: 2px solid black`
                });
                return n;
            });
            entityNodes.add(Id); // Mark this entity as added
            yPosition += 400;
        }

        // Add edge between the collection and the corresponding entity
        const source = swapArrow ? entity : Id;
        const target = swapArrow ? Id : entity;
        const sourceHandle = swapArrow ? `${entity}-left` : `${Id}-right`; // Use personNode right or entityNode left
        const targetHandle = swapArrow ? `${Id}-right` : `${entity}-left`; // Use entityNode left or personNode right

        edges.update(e => {
            e.push({
                id: `${Id}-${entity}`,
                source:source,
                target:target,
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: 'color: black;',
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
// ADD ORGANISATIONS
export function addOrga ({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgeStyle
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgeStyle: string
}) {
    let yPosition = 0;
    const entityNodes = new Set();
    for (const [id, member] of Object.entries(dataset)) {
        const Id = member[IdName]; // Use name as the ID
        const entity = member[EntityName];
        
        // Only add the collection node if it hasn't been added yet
        if (!entityNodes.has(Id)) {
            // Add node
            nodes.update(n => {
                n.push({
                    id: Id,
                    type: 'orgaNode',
                    data: {
                        orga: Id,
                        rorid: 'XXX-XXXX-XX'
                     },
                    position: { x:-800, y: yPosition }, // Adjust position as needed
                    style: `background: ${color}; ${border_radius}; width: ${Id.length*10}px;${height}; border: 2px solid black`
                });
                return n;
            });
            entityNodes.add(Id); // Mark this entity as added
            yPosition += 400;
        }

        // Add edge between the collection and the corresponding entity
        const source = swapArrow ? entity : Id;
        const target = swapArrow ? Id : entity;
        edges.update(e => {
            e.push({
                id: `${Id}-${entity}`,
                source:source,
                target:target,
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: 'color: black;',
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------



//ADD Nodes and Edges for Software
export function addSoftware({
    dataset,
    nodes,
    edges,
    color,
    border_radius,
    height,
    EdgeLabel,
    IdName,
    EntityName,
    style,
    swapArrow,
    edgestyle
}: {
    dataset: any, 
    nodes: any,
    edges: any,
    color: string,
    border_radius: string,
    height: string,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    style: string,
    swapArrow: boolean,
    edgestyle: string
}) {
    let yPosition = 0;
    for (const member of Object.values(dataset)) {
        const activityId = member[IdName];
        const agentId = member[EntityName];
        
        // Ensure agent node is added if not present
        nodes.update(n => {
            if (!n.some(node => node.id === agentId)) {
                n.push({
                    id: agentId,
                    type: 'softwareNode',
                    data: {
                        software: agentId,
                        source: 'www.example.com',
                        version: '1.7',
                        repository: 'https://github.com/rue-a/provo?tab=readme-ov-file',
                        license: 'MIT'
                     },
                    position: { x: 1200, y: yPosition }, // Adjust as needed
                    style: `background: ${color}; ${border_radius}; width: ${agentId.length*10}px;${height}; border: 2px solid black`
                });
            }
            return n;
        });
        yPosition += 400;

        // Define edge direction based on swapArrow
        const source = swapArrow ? agentId : activityId;
        const target = swapArrow ? activityId : agentId;
        const sourceHandle = swapArrow ? `${agentId}-left` : `${activityId}-right`; // Use the correct handle
        const targetHandle = swapArrow ? `${activityId}-right` : `${agentId}-left`; // Use the correct handle
        
        // Add edge between the activity and agent
        edges.update(e => {
            e.push({
                id: `${activityId}-${agentId}`,
                source: source,
                target: target, 
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: edgestyle,
                labelStyle: 'color: black;',
            });
            return e;
        });
    }
}


// ADD EDGES ONLY
export function addEdgesOnly({
    dataset,
    edges,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    style,
    labelStyle,
    handle1,
    handle2
    //edgeStyle = {} // Allow optional edge style customization
}: {
    dataset: any, 
    edges: any,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    style: string,
    labelStyle: string,
    handle1: string,
    handle2: string
}) {
    for (const member of Object.values(dataset)) {
        const activityId = member[IdName];
        const entityId = member[EntityName];
        
        // Define edge direction based on swapArrow
        const source = swapArrow ? entityId : activityId;
        const target = swapArrow ? activityId : entityId;

        // Specify the correct handles for source and target
        const sourceHandle = swapArrow ? `${entityId}-${handle1}` : `${activityId}-${handle2}`; // Use entityNode right or activityNode left
        const targetHandle = swapArrow ? `${activityId}-${handle2}` : `${entityId}-${handle1}`; // Use activityNode left or entityNode right
        
        // Add edge between activity and entity
        edges.update(e => {
            e.push({
                id: `${activityId}-${entityId}`,
                source: source,
                target: target,
                sourceHandle: sourceHandle, // Assign the correct source handle
                targetHandle: targetHandle, // Assign the correct target handle
                animated: false,
                label: EdgeLabel,
                style: style,
                labelStyle: labelStyle
            });
            return e;
        });
    }
}

