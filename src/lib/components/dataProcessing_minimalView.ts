//WAS GENERATED BY
//----------------------------------------------------------------------------------------
export function findFirstEntity(generatedToUsedMap: any, usedToGeneratedMap: any) {
    // Find the first entity that is generated but not used by another
    return Array.from(generatedToUsedMap.keys()).filter(generated => {
        return !Array.from(usedToGeneratedMap.keys()).includes(generated);
    });
}
//------------------------------------------------------------
export function createEntityFlowCore(
    wasDerivedFrom: any,
    GeneratedName: string,
    UsedName: string ) 
    {
    // Create maps to store relationships
    const generatedToUsedMap = new Map<string, string[]>();
    const usedToGeneratedMap = new Map<string, string[]>();

    // Populate the maps
    for (const entry of Object.values(wasDerivedFrom)) {
        const generated = entry[GeneratedName]; //'prov:generatedEntity'
        const used = entry[UsedName]; // 'prov:usedEntity'

        // Update generatedToUsedMap
        if (!generatedToUsedMap.has(generated)) {
            generatedToUsedMap.set(generated, []);
        }
        generatedToUsedMap.get(generated)!.push(used);

        // Update usedToGeneratedMap
        if (!usedToGeneratedMap.has(used)) {
            usedToGeneratedMap.set(used, []);
        }
        usedToGeneratedMap.get(used)!.push(generated);
    }

    const startEntities = findFirstEntity (generatedToUsedMap,   usedToGeneratedMap)

    return { startEntities , generatedToUsedMap};
}
//-----------------------------------------------------------------------

export function createEntityFlow(
    entity: any, 
    nodes: any, 
    edges: any,
    label:string,
    swapArrow: boolean,
    generatedToUsedMap: Map<string, string[]>,
    nodeType: string,
    xPos:number ):void {
    // Function to print all derivations starting from a given entity
    let queue = [entity];
    let visited = new Set<string>();
    let yPosition = 0;

    while (queue.length > 0) {
        let currentEntity = queue.shift()!;
        if (visited.has(currentEntity)) continue;
        visited.add(currentEntity);

        // Add node for currentEntity
        nodes.update(n => {
            if (!n.some(node => node.id === currentEntity)) {
                n.push({
                    id: currentEntity,
                    type: nodeType,
                    data: { label: currentEntity },
                    position: { x: xPos, y: yPosition },
                });
                yPosition += 400;
            }
            return n;
        });

        // Get all entities that this one was derived from
        if (generatedToUsedMap.has(currentEntity)) {
            for (const usedEntity of generatedToUsedMap.get(currentEntity)!) {
                // Add edge between the current entity and the used entity
                const source = swapArrow ? usedEntity : currentEntity;
                const target = swapArrow ? currentEntity : usedEntity;

                const sourceHandle = swapArrow ? `${usedEntity}-top` : `${currentEntity}-bottom`;
                const targetHandle = swapArrow ? `${currentEntity}-bottom` : `${usedEntity}-top`;
                edges.update(e => {
                    e.push({
                        id: `${usedEntity}-${currentEntity}`,
                        source: source,
                        target: target,
                        animated: false,
                        label: label,
                        labelStyle: "color: black; font-size: 16px;",
                        sourceHandle: sourceHandle,
                        targetHandle: targetHandle
                    });
                    return e;
                });

                // Continue traversing from the used entity
                queue.push(usedEntity);
            }
        }
    }    
}
//-----------------------------------------------------------------------------

// ADD FLOW
export function createFlow ({
    dataset,
    nodes,
    edges,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgeStyle,
    nodeType,
    xPos
}: {
    dataset: any, 
    nodes: any, 
    edges: any,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgeStyle: string,
    nodeType: string,
    xPos:number
}) {
    // Process hadMember to create collections
    const entityNodes = new Set(); // Keep track of added collection nodes
    let yPosition = 0;
    for (const [id, member] of Object.entries(dataset)) {
        const Id = member[IdName]; // Use collection name as the ID
        const entity = member[EntityName];
        
        // Only add the collection node if it hasn't been added yet
        if (!entityNodes.has(Id)) {
            // Add collection node
            nodes.update(n => {
                n.push({
                    id: Id,
                    type: nodeType,
                    data: { label: Id },
                    position: { x: xPos, y:yPosition }, // Adjust position as needed
                });
                
                return n;
            });
            yPosition += 400;
            entityNodes.add(Id); // Mark this entity as added
        }

        // Add edge between the collection and the corresponding entity
        const source = swapArrow ? entity : Id;
        const target = swapArrow ? Id : entity;

        const sourceHandle = swapArrow ? `${entity}-left` : `${Id}-right`;
        const targetHandle = swapArrow ? `${Id}-right` : `${entity}-left`;
        edges.update(e => {
            e.push({
                id: `${Id}-${entity}`,
                source:source,
                target:target,
                animated: false,
                label: EdgeLabel,
                style: edgeStyle,
                labelStyle: "color: black; font-size: 16px;",
                sourceHandle: sourceHandle,
                targetHandle: targetHandle
            });
            return e;
        });
    }
}
//-----------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------



//ADD Nodes and Edges for Software
export function addSoftware({
    dataset,
    nodes,
    edges,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    edgestyle,
    nodeType,
    xPos
}: {
    dataset: any, 
    nodes: any,
    edges: any,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    edgestyle: string,
    nodeType: string,
    xPos:number
}) {
    let yPosition = 0;
    for (const member of Object.values(dataset)) {
        const activityId = member[IdName];
        const agentId = member[EntityName];
        
        // Ensure agent node is added if not present
        nodes.update(n => {
            if (!n.some(node => node.id === agentId)) {
                n.push({
                    id: agentId,
                    type: nodeType,
                    data: { label: agentId },
                    position: { x: xPos, y: yPosition }, // Adjust as needed
                });
                yPosition += 400;
            }
            return n;
        });

        // Define edge direction based on swapArrow
        const source = swapArrow ? agentId : activityId;
        const target = swapArrow ? activityId : agentId;

        const sourceHandle = swapArrow ? `${agentId}-left` : `${activityId}-right`;
        const targetHandle = swapArrow ? `${activityId}-right` : `${agentId}-left`;
        
        // Add edge between the activity and agent
        edges.update(e => {
            e.push({
                id: `${activityId}-${agentId}`,
                source: source,
                target: target,
                animated: false,
                label: EdgeLabel,
                style: edgestyle,
                labelStyle: "color: black; font-size: 16px;" ,
                sourceHandle: sourceHandle,
                targetHandle: targetHandle
            });
            return e;
        });
    }
}


// ADD EDGES ONLY
export function addEdgesOnly({
    dataset,
    edges,
    EdgeLabel,
    IdName,
    EntityName,
    swapArrow,
    style,
    labelStyle,
    handle1,
    handle2
    //edgeStyle = {} // Allow optional edge style customization
}: {
    dataset: any, 
    edges: any,
    EdgeLabel: string,
    IdName: string,
    EntityName: string,
    swapArrow: boolean,
    style: string,
    labelStyle: string,
    handle1: string,
    handle2: string
}) {
    for (const member of Object.values(dataset)) {
        const activityId = member[IdName];
        const entityId = member[EntityName];
        
        // Define edge direction based on swapArrow
        const source = swapArrow ? entityId : activityId;
        const target = swapArrow ? activityId : entityId;

        // Specify the correct handles for source and target
        const sourceHandle = swapArrow ? `${entityId}-${handle1}` : `${activityId}-${handle2}`; // Use entityNode right or activityNode left
        const targetHandle = swapArrow ? `${activityId}-${handle2}` : `${entityId}-${handle1}`; // Use activityNode left or entityNode right
        
        // Add edge between activity and entity
        edges.update(e => {
            e.push({
                id: `${activityId}-${entityId}`,
                source: source,
                target: target,
                animated: false,
                label: EdgeLabel,
                style: style,
                labelStyle: labelStyle,
                sourceHandle: sourceHandle,
                targetHandle: targetHandle
            });
            return e;
        });
    }
}

